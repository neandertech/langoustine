<!DOCTYPE html><html data-githubContributorsUrl="https://api.github.com/repos/neandertech/langoustine" data-githubContributorsFilename="docs/_docs/getting_started.md" data-pathToRoot=""><head><meta charset="utf-8"></meta><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"></meta><title>Getting started</title><link rel="shortcut icon" type="image/x-icon" href="favicon.ico"></link><script type="text/javascript" src="scripts/theme.js"></script><script type="text/javascript" src="scripts/searchData.js" defer="true"></script><script type="text/javascript" src="scripts/scastieConfiguration.js" defer="true"></script><link rel="stylesheet" href="styles/theme/bundle.css"></link><link rel="stylesheet" href="styles/theme/components/bundle.css"></link><link rel="stylesheet" href="styles/theme/components/button/bundle.css"></link><link rel="stylesheet" href="styles/theme/layout/bundle.css"></link><link rel="stylesheet" href="styles/nord-light.css"></link><link rel="stylesheet" href="styles/dotty-icons.css"></link><link rel="stylesheet" href="styles/filter-bar.css"></link><link rel="stylesheet" href="styles/code-snippets.css"></link><link rel="stylesheet" href="styles/searchbar.css"></link><link rel="stylesheet" href="styles/social-links.css"></link><link rel="stylesheet" href="styles/versions-dropdown.css"></link><link rel="stylesheet" href="styles/content-contributors.css"></link><link rel="stylesheet" href="styles/fontawesome.css"></link><script type="text/javascript" src="hljs/highlight.pack.js" defer="true"></script><script type="text/javascript" src="scripts/hljs-scala3.js" defer="true"></script><script type="text/javascript" src="scripts/ux.js" defer="true"></script><script type="text/javascript" src="scripts/common/component.js" defer="true"></script><script type="text/javascript" src="scripts/common/utils.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterBar.js" defer="true"></script><script type="text/javascript" src="scripts/components/DocumentableList.js" defer="true"></script><script type="text/javascript" src="scripts/components/Input.js" defer="true"></script><script type="text/javascript" src="scripts/components/FilterGroup.js" defer="true"></script><script type="text/javascript" src="scripts/components/Filter.js" defer="true"></script><script type="text/javascript" src="scripts/scaladoc-scalajs.js" defer="true"></script><script type="text/javascript" src="scripts/contributors.js" defer="true"></script><script type="text/javascript" src="https://code.jquery.com/jquery-3.5.1.min.js" defer="true"></script><script type="text/javascript" src="https://d3js.org/d3.v6.min.js" defer="true"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/graphlib-dot@0.6.2/dist/graphlib-dot.min.js" defer="true"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dagre-d3/0.6.1/dagre-d3.min.js" defer="true"></script><script type="text/javascript" src="https://scastie.scala-lang.org/embedded.js" defer="true"></script><script type="text/javascript" src="scripts/data.js" defer="true"></script><link rel="stylesheet" href="styles/staticsitestyles.css"></link><script>var pathToRoot = "";</script></head><body><div id=""><div id="header" class="body-small"><div class="header-container-left"><a href="" class="logo-container"><span class="project-name h300">Langoustine</span></a><span onclick="dropdownHandler(event)" class="text-button with-arrow" id="dropdown-trigger"><a><div class="projectVersion">0.0.21+19-463927fc-SNAPSHOT</div></a></span><div id="version-dropdown" class="dropdown-menu"></div></div><div class="header-container-right"><button id="search-toggle" class="icon-button"></button><span id="theme-toggle" class="icon-button"></span><span id="mobile-menu-toggle" class="icon-button hamburger"></span></div></div><div id="mobile-menu"><div class="mobile-menu-header body-small"><span class="mobile-menu-logo"><span class="project-name h300">Langoustine</span></span><button id="mobile-menu-close" class="icon-button close"></button></div><div class="mobile-menu-container body-medium"><input id="mobile-scaladoc-searchbar-input" class="scaladoc-searchbar-input" type="search" placeholder="Find anything"></input><span id="mobile-theme-toggle" class="mobile-menu-item mode"></span></div></div><span id="mobile-sidebar-toggle" class="floating-button"></span><div id="leftColumn" class="body-small"><div class="switcher-container"><a id="docs-nav-button" class="switcher h100 selected" href="index.html">Docs</a><a id="api-nav-button" class="switcher h100 " href="api/index.html">API</a></div><nav id="docs-nav" class="side-menu"><div class="ni n0 expanded"><span class="nh h100 selected de"><a href="#"><span>Getting started</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="tracer.html"><span>Tracer</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="toolkit.html"><span>LSP Toolkit</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="examples.html"><span>Examples</span></a></span></div><div class="ni n0 "><span class="nh de"><a href="CONTRIBUTING.html"><span>Contributing guide</span></a></span></div></nav></div><div id="footer" class="body-small"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/neandertech/langoustine"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Neandertech</div></div><div class="text-mobile">Copyright (c) 2022, Neandertech</div></div><div id="scaladoc-searchBar"></div><div id="main"><div class="breadcrumbs container"><a href="index.html">Langoustine</a>/<a href="getting_started.html">Getting started</a></div><div id="content" class="body-medium"><div><section id="getting-started-1">
 <h1 class="h500"><a href="#getting-started-1" class="anchor"></a>Getting started</h1>
 <p>When writing a LSP server with langoustine, there is usually two main components:</p>
 <ol>
  <li>
   <p>Definition of endpoints (currently the only way to define them is using <code>LSPBuilder</code>)</p>
   <p>This is the meat and bones of your LSP server - all the logic regarding the processing of inputs, sending responses, publishing diagnostics, maintaining internal state, etc. lives here</p></li>
  <li>
   <p>Transport layer integration</p>
   <p>While Langoustine gives you strongly typed data models to operate with, eventually they need to be converted to JSONRPC payloads and then to a stream of bytes that are exchanged between the client (editor) and the server.</p>
   <p>This integration rarely needs to be modified and the hard part is provided by the excellent <a href="https://github.com/neandertech/jsonrpclib">jsonrpclib</a> project.</p></li>
 </ol>
 <p>To make it trivial to convert your server definition (1) into a runnable app which can be launched by<br>
   the LSP client, we provide a <code>LangoustineApp</code>.</p>
 <p>Let's take a look at a simple example.</p>
</section>
<section id="example-with-scala-cli-1">
 <h2 class="h500"><a href="#example-with-scala-cli-1" class="anchor"></a>Example with Scala CLI</h2>
 <p>Let's build a small, single-file LSP server using the <a href="https://scala-cli.virtuslab.org/">Scala CLI</a>. Everything done here can be achieved with SBT or Mill, it's just easier to use Scala CLI for this demonstration.</p>
 <p>The LSP will be very simple:</p>
 <ol>
  <li>
   <p>Only operates on files with <code>.langoustine</code> extension (this will become important only for editor integration)</p></li>
  <li>
   <p>It should send a window notification (<a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#window_showMessage"><code>window/showMessage</code></a> when the server start processing a response to <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#initialize">initialize</a> request</p></li>
  <li>
   <p>Whenever a document is opened (<a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_didOpen"><code>textDocument/didOpen</code></a>, we should track the full path of it in some in-memory state</p>
   <p>a. Once the document is persisted in memory, we should send a window notification with the total count of currently tracked documents</p></li>
 </ol>
</section>
<section id="using-cats-effect-recommended-1">
 <h3 class="h400"><a href="#using-cats-effect-recommended-1" class="anchor"></a>Using Cats Effect (recommended)</h3>
 <p>In this example, we will be using <a href="https://typelevel.org/cats-effect/docs/getting-started">Cats Effect</a> and the concurrency-safe primitives it provides. While it is strongly recommended to use Langoustine with Cats Effect, it's not necessary. Read on if you want to see a version which uses <code>Future</code> instead.</p>
 <p>Here's the entire code, as a single <code>lsp.definition.scala</code> file:</p>
 <div class="snippet mono-small-block" scala-snippet="" runnable="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>//&gt; using repository "sonatype-s01:snapshots"
</span><span line-number="2" class=""><span class="tooltip-container"></span>//&gt; using lib "tech.neander::langoustine-lsp::0.0.21+19-463927fc-SNAPSHOT"
</span><span line-number="3" class=""><span class="tooltip-container"></span>//&gt; using lib "tech.neander::langoustine-app::0.0.21+19-463927fc-SNAPSHOT"
</span><span line-number="4" class=""><span class="tooltip-container"></span>//&gt; using scala "3.2"
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>import langoustine.lsp.*
</span><span line-number="7" class=""><span class="tooltip-container"></span>import langoustine.lsp.all.*
</span><span line-number="8" class=""><span class="tooltip-container"></span>import langoustine.lsp.app.*
</span><span line-number="9" class=""><span class="tooltip-container"></span>import jsonrpclib.fs2.*
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>import cats.effect.*
</span><span line-number="12" class=""><span class="tooltip-container"></span>
</span><span line-number="13" class=""><span class="tooltip-container"></span>object MyServer extends LangoustineApp.Simple:
</span><span line-number="14" class=""><span class="tooltip-container"></span>  override def server =
</span><span line-number="15" class=""><span class="tooltip-container"></span>    IO.ref(Set.empty[String]).map(myLSP)
</span><span line-number="16" class=""><span class="tooltip-container"></span>
</span><span line-number="17" class=""><span class="tooltip-container"></span>def myLSP(files: Ref[IO, Set[String]]) =
</span><span line-number="18" class=""><span class="tooltip-container"></span>  LSPBuilder
</span><span line-number="19" class=""><span class="tooltip-container"></span>    .create[IO]
</span><span line-number="20" class=""><span class="tooltip-container"></span>    .handleRequest(initialize) { in =&gt;
</span><span line-number="21" class=""><span class="tooltip-container"></span>      sendMessage(in.toClient, "ready to initialise!") *&gt;
</span><span line-number="22" class=""><span class="tooltip-container"></span>        IO {
</span><span line-number="23" class=""><span class="tooltip-container"></span>          InitializeResult(
</span><span line-number="24" class=""><span class="tooltip-container"></span>            capabilities = ServerCapabilities(textDocumentSync =
</span><span line-number="25" class=""><span class="tooltip-container"></span>              Opt(TextDocumentSyncKind.Full)
</span><span line-number="26" class=""><span class="tooltip-container"></span>            ),
</span><span line-number="27" class=""><span class="tooltip-container"></span>            serverInfo = Opt(InitializeResult.ServerInfo("My first LSP!"))
</span><span line-number="28" class=""><span class="tooltip-container"></span>          )
</span><span line-number="29" class=""><span class="tooltip-container"></span>        }
</span><span line-number="30" class=""><span class="tooltip-container"></span>    }
</span><span line-number="31" class=""><span class="tooltip-container"></span>    .handleNotification(textDocument.didOpen) { in =&gt;
</span><span line-number="32" class=""><span class="tooltip-container"></span>      val documentUri = in.params.textDocument.uri.value
</span><span line-number="33" class=""><span class="tooltip-container"></span>      files.updateAndGet(_ + documentUri).map(_.size).flatMap { count =&gt;
</span><span line-number="34" class=""><span class="tooltip-container"></span>        sendMessage(in.toClient, s"In total, $count files registered!")
</span><span line-number="35" class=""><span class="tooltip-container"></span>      }
</span><span line-number="36" class=""><span class="tooltip-container"></span>    }
</span><span line-number="37" class=""><span class="tooltip-container"></span>
</span><span line-number="38" class=""><span class="tooltip-container"></span>def sendMessage(back: Communicate[IO], msg: String) =
</span><span line-number="39" class=""><span class="tooltip-container"></span>  back.notification(
</span><span line-number="40" class=""><span class="tooltip-container"></span>    window.showMessage,
</span><span line-number="41" class=""><span class="tooltip-container"></span>    ShowMessageParams(MessageType.Info, msg)
</span><span line-number="42" class=""><span class="tooltip-container"></span>  )
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <ol>
  <li>
   <p><code>langoustine-app</code> dependency brings in <code>LangoustineApp</code> trait</p>
   <p>We are using the <code>LangoustineApp.Simple</code> variation, where server definition does not depend on any of the command line arguments.</p>
   <p>The design is heavily inspired by <code>IOApp</code> from Cats Effect.</p></li>
  <li>
   <p><code>myLSP</code> is the definition of our LSP server - it only handles a <code>initialize</code> request and a <code>textDocument/didOpen</code> notification.</p>
   <p>It carries internal state in the form of a <code>Ref[IO, Set[String]]</code> which is a thread-safe storage of unique document URIs</p></li>
  <li>
   <p>When we respond to the <code>initialize</code> request, we also inform the client that we're happy to receive document syncing notifications by setting <code>textDocumentSync = Opt(TextDocumentSyncKind.Full)</code> in the response.</p>
   <p>Without this, clients won't be sending <code>textDocument/didOpen</code> notifications that we need.</p></li>
  <li>
   <p><code>sendMessage</code> is a small helper to send notifications back to the client, using the <code>window/showMessage</code> method.</p></li>
 </ol>
</section>
<section id="using-future-1">
 <h3 class="h400"><a href="#using-future-1" class="anchor"></a>Using <code>Future</code></h3>
 <p>If for whatever reason you find working with <code>Future</code> easier, we provide a <code>Langoustine.FromFuture</code> app builder - it behaves in the same way, but doesn't expect your LSP to use <code>IO</code>.</p>
 <p>Our app is therefore rewritten in this way:</p>
 <div class="snippet mono-small-block" scala-snippet="" runnable="">
  <pre><code class="language-scala"><span line-number="1" class=""><span class="tooltip-container"></span>//&gt; using repository "sonatype-s01:snapshots"
</span><span line-number="2" class=""><span class="tooltip-container"></span>//&gt; using lib "tech.neander::langoustine-lsp::0.0.21+19-463927fc-SNAPSHOT"
</span><span line-number="3" class=""><span class="tooltip-container"></span>//&gt; using lib "tech.neander::langoustine-app::0.0.21+19-463927fc-SNAPSHOT"
</span><span line-number="4" class=""><span class="tooltip-container"></span>//&gt; using scala "3.2"
</span><span line-number="5" class=""><span class="tooltip-container"></span>
</span><span line-number="6" class=""><span class="tooltip-container"></span>import langoustine.lsp.*
</span><span line-number="7" class=""><span class="tooltip-container"></span>import langoustine.lsp.all.*
</span><span line-number="8" class=""><span class="tooltip-container"></span>import langoustine.lsp.app.*
</span><span line-number="9" class=""><span class="tooltip-container"></span>import scala.concurrent.Future
</span><span line-number="10" class=""><span class="tooltip-container"></span>
</span><span line-number="11" class=""><span class="tooltip-container"></span>import cats.instances.future._
</span><span line-number="12" class=""><span class="tooltip-container"></span>import scala.concurrent.ExecutionContext
</span><span line-number="13" class=""><span class="tooltip-container"></span>import scala.collection.concurrent.TrieMap
</span><span line-number="14" class=""><span class="tooltip-container"></span>
</span><span line-number="15" class=""><span class="tooltip-container"></span>object MyFutureServer extends LangoustineApp.FromFuture.Simple:
</span><span line-number="16" class=""><span class="tooltip-container"></span>  given ExecutionContext = ExecutionContext.global
</span><span line-number="17" class=""><span class="tooltip-container"></span>  override def server = Future(myFutureLSP(TrieMap.empty))
</span><span line-number="18" class=""><span class="tooltip-container"></span>
</span><span line-number="19" class=""><span class="tooltip-container"></span>def myFutureLSP(
</span><span line-number="20" class=""><span class="tooltip-container"></span>    files: TrieMap[String, Boolean]
</span><span line-number="21" class=""><span class="tooltip-container"></span>)(implicit ec: ExecutionContext) =
</span><span line-number="22" class=""><span class="tooltip-container"></span>  LSPBuilder
</span><span line-number="23" class=""><span class="tooltip-container"></span>    .create[Future]
</span><span line-number="24" class=""><span class="tooltip-container"></span>    .handleRequest(initialize) { in =&gt;
</span><span line-number="25" class=""><span class="tooltip-container"></span>      sendMessage(in.toClient, "ready to initialise a future LSP!")
</span><span line-number="26" class=""><span class="tooltip-container"></span>      Future {
</span><span line-number="27" class=""><span class="tooltip-container"></span>        InitializeResult(
</span><span line-number="28" class=""><span class="tooltip-container"></span>          capabilities = ServerCapabilities(textDocumentSync =
</span><span line-number="29" class=""><span class="tooltip-container"></span>            Opt(TextDocumentSyncKind.Full)
</span><span line-number="30" class=""><span class="tooltip-container"></span>          ),
</span><span line-number="31" class=""><span class="tooltip-container"></span>          serverInfo = Opt(InitializeResult.ServerInfo("My first LSP!"))
</span><span line-number="32" class=""><span class="tooltip-container"></span>        )
</span><span line-number="33" class=""><span class="tooltip-container"></span>      }
</span><span line-number="34" class=""><span class="tooltip-container"></span>    }
</span><span line-number="35" class=""><span class="tooltip-container"></span>    .handleNotification(textDocument.didOpen) { in =&gt;
</span><span line-number="36" class=""><span class="tooltip-container"></span>      val documentUri = in.params.textDocument.uri.value
</span><span line-number="37" class=""><span class="tooltip-container"></span>      files.update(documentUri, true)
</span><span line-number="38" class=""><span class="tooltip-container"></span>      sendMessage(in.toClient, s"In total, ${files.size} files registered!")
</span><span line-number="39" class=""><span class="tooltip-container"></span>    }
</span><span line-number="40" class=""><span class="tooltip-container"></span>
</span><span line-number="41" class=""><span class="tooltip-container"></span>def sendMessage(back: Communicate[Future], msg: String) =
</span><span line-number="42" class=""><span class="tooltip-container"></span>  back.notification(
</span><span line-number="43" class=""><span class="tooltip-container"></span>    window.showMessage,
</span><span line-number="44" class=""><span class="tooltip-container"></span>    ShowMessageParams(MessageType.Info, msg)
</span><span line-number="45" class=""><span class="tooltip-container"></span>  )
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Note that the LSP is almost identical!</p>
 <p>Only changes were:</p>
 <ol>
  <li>Using <code>TrieMap</code> to maintain our state in a thread safe manner</li>
  <li>Passing around ExecutionContext</li>
  <li>Not chaining <code>Future</code>s together when not necessary - they're eagerly evaluated and will run in parallel</li>
 </ol>
 <p>Note that it's the same dependencies and mostly the same imports - the underlying input/output machinery is still the same, we're just making the <code>IO</code> -&gt; <code>Future</code> translation for you in a hopefully safe fashion.</p>
</section>
<section id="packaging-and-distribution-1">
 <h2 class="h500"><a href="#packaging-and-distribution-1" class="anchor"></a>Packaging and distribution</h2>
 <p>The way 99% of LSP integrations works is by the editor launching a specified command, and connecting to it via STDIN/STDOUT.</p>
 <p>As a first iteration, we can just use Scala CLI itself!</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>$ scala-cli run lsp.definition.scala
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>You could give this command to the editor of your choosing and it will launch the server for you.</p>
 <p>Note that with Scala CLI you can package it even easier into a bootstrap jar:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>$ scli package . -f -o LSP
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>and use <code>LSP</code> as the binary!</p>
</section>
<section id="publishing-and-launching-with-coursier-1">
 <h3 class="h400"><a href="#publishing-and-launching-with-coursier-1" class="anchor"></a>Publishing and launching with Coursier</h3>
 <p>Another way is to publish our LSP server as a JVM app and use <a href="https://get-coursier.io/docs/overview">Coursier</a> to bootstrap and launch it.</p>
 <p>When we publish our application to Maven Central, it can be launched as easily as</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>$ cs launch com.example::my-lsp:latest.release
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>You can even publish it to internal artifactory and modify the list of repositories Coursier uses.</p>
 <p>One benefit of this model of distribution is that new versions will be automatically downloaded, and you don't need to do any extra packaging - coursier will download all the necessary dependencies.</p>
 <p>A downside is that you need both the JVM and Coursier installed on user's machine.</p>
</section>
<section id="packaging-for-nodejs-and-pkg-1">
 <h3 class="h400"><a href="#packaging-for-nodejs-and-pkg-1" class="anchor"></a>Packaging for Node.js and Pkg</h3>
 <p>Given that we are in the warm, molasses like, embrace of Scala, we have a secret weapon available to us - Scala.js.</p>
 <p>If we are lucky enough to not use any Java dependencies and only use Scala libraries that have been cross-published for Scala.js, we have another way of packaging the app with some attractive features.</p>
 <p>Sometimes it's even easier to write your LSP entirely targeting Scala.js - if you are using a JavaScript/TypeScript library for example.</p>
 <p>To package our LSP into a single uber-JS file, we can run this command:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>$ scli package . --js --js-module-kind common -f -o LSP.js
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>This LSP can be run with <code>node LSP.js</code> and behave exactly like the JVM version, if you don't count it being single threaded and being a completely different runtime..</p>
 <p>But we can take it further - as JavaScript is an interpreted language, we can embed our generated JS file, along with the interpreter (Node.js) into a single, self-contained binary.</p>
 <p>That's exactly what <a href="https://github.com/vercel/pkg">Pkg</a> can do for us. You can install it by running <code>npm i -g pkg</code>.</p>
 <p>After it's installed, all you need to do is point it at the location of your JS files:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>$ mkdir binaries
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>$ pkg LSP.js --out-path binaries
</span><span line-number="4" class=""><span class="tooltip-container"></span>&gt; pkg@5.8.0
</span><span line-number="5" class=""><span class="tooltip-container"></span>&gt; Targets not specified. Assuming:
</span><span line-number="6" class=""><span class="tooltip-container"></span>  node16-linux-arm64, node16-macos-arm64, node16-win-arm64
</span><span line-number="7" class=""><span class="tooltip-container"></span>
</span><span line-number="8" class=""><span class="tooltip-container"></span>$ l binaries --no-user
</span><span line-number="9" class=""><span class="tooltip-container"></span>.rwxr-xr-x 52M 15 Sep 17:54  LSP-linux
</span><span line-number="10" class=""><span class="tooltip-container"></span>.rwxr-xr-x 54M 15 Sep 17:55  LSP-macos
</span><span line-number="11" class=""><span class="tooltip-container"></span>.rw-r--r-- 36M 15 Sep 17:55  LSP-win.exe
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Note that because all Pkg is doing is embedding scripts into existing runtime, you can produce self-contained binaries for any platform! All it needs to do is download the correct distribution from Node.js' website.</p>
 <p>This is a very interesting distribution mechanism and that's how an LSP for Tree Sitter grammars is distributed: <a href="https://github.com/keynmol/grammar-js-lsp/releases/tag/v0.0.3">https://github.com/keynmol/grammar-js-lsp/releases/tag/v0.0.3</a></p>
</section>
<section id="packaging-as-a-native-application-1">
 <h3 class="h400"><a href="#packaging-as-a-native-application-1" class="anchor"></a>Packaging as a native application</h3>
 <p>As of quite recently, foundational libraries that power the transport mechanism in langoustine have been published for Scala Native.</p>
 <p>With that, we can easily package our example as a truly native app, without any dependencies:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>$ scli package lsp.definition.scala --native -f -o LSP.native
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>We can verify that it is indeed a binary and it has no external dependencies:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-text"><span line-number="1" class=""><span class="tooltip-container"></span>$ file LSP.native
</span><span line-number="2" class=""><span class="tooltip-container"></span>LSP.native: Mach-O 64-bit executable arm64 # on your machine it will be different
</span><span line-number="3" class=""><span class="tooltip-container"></span>
</span><span line-number="4" class=""><span class="tooltip-container"></span>$ l --no-user LSP.native
</span><span line-number="5" class=""><span class="tooltip-container"></span>.rwxr-xr-x 21M 17 Sep 11:58  LSP.native
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>Both Scala Native and the Langoustine support for it are experimental, so do give it a go and report any issues!</p>
</section>
<section id="editor-integration-1">
 <h2 class="h500"><a href="#editor-integration-1" class="anchor"></a>Editor integration</h2>
 <p>This section eagerly awaits your contributions!</p>
</section>
<section id="neovim-1">
 <h3 class="h400"><a href="#neovim-1" class="anchor"></a>Neovim</h3>
 <p>In Neovim nightly, adding a custom LSP server is very simple. For a new filetype (like <strong>.langoustine</strong>) it's done in two steps:</p>
 <ol>
  <li>Registering the filetype:</li>
 </ol>
 <div class="snippet mono-small-block">
  <pre><code class="language-lua"><span line-number="1" class=""><span class="tooltip-container"></span><span class="hideable">  </span>vim.api.nvim_create_autocmd({ "BufRead", "BufNewFile" }, {
</span><span line-number="2" class=""><span class="tooltip-container"></span><span class="hideable">  </span>  pattern = { "*.langoustine" },
</span><span line-number="3" class=""><span class="tooltip-container"></span><span class="hideable">  </span>  callback = function() vim.cmd("setfiletype langoustine") end
</span><span line-number="4" class=""><span class="tooltip-container"></span><span class="hideable">  </span>})
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <ol start="2">
  <li>
   <p>Adding a LSP configuration for that filetype.</p>
   <p>This is where we should have selected a command to launch our server. Let's say in this example I chose to use the built jar:</p></li>
 </ol>
 <div class="snippet mono-small-block">
  <pre><code class="language-lua"><span line-number="1" class=""><span class="tooltip-container"></span>local lsp = vim.api.nvim_create_augroup("LSP", { clear = true })
</span><span line-number="2" class=""><span class="tooltip-container"></span>
</span><span line-number="3" class=""><span class="tooltip-container"></span>vim.api.nvim_create_autocmd("FileType", {
</span><span line-number="4" class=""><span class="tooltip-container"></span>  group = lsp,
</span><span line-number="5" class=""><span class="tooltip-container"></span>  pattern = "langoustine",
</span><span line-number="6" class=""><span class="tooltip-container"></span>  callback = function()
</span><span line-number="7" class=""><span class="tooltip-container"></span>    vim.lsp.start({
</span><span line-number="8" class=""><span class="tooltip-container"></span>      name = "Langoustine LSP",
</span><span line-number="9" class=""><span class="tooltip-container"></span>      cmd = { '/path/to/LSP' }
</span><span line-number="10" class=""><span class="tooltip-container"></span>    })
</span><span line-number="11" class=""><span class="tooltip-container"></span>  end,
</span><span line-number="12" class=""><span class="tooltip-container"></span>})
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>If I wanted to use coursier instead, I would need to use the following format, given that the command is actually a list of arguments:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-lua"><span line-number="1" class=""><span class="tooltip-container"></span>cmd = { 'cs', 'launch', 'com.example::my-lsp:latest.release' }
</span></code></pre>
  <div class="buttons"></div>
 </div>
 <p>And that's it! Next time I open some <code>.langoustine</code> files I can see these messages:</p>
 <div class="snippet mono-small-block">
  <pre><code class="language-"><span line-number="1" class=""><span class="tooltip-container"></span>"[Prompt]" [Modified] 1 line --100%--
</span><span line-number="2" class=""><span class="tooltip-container"></span>"test.langoustine" 0L, 0B
</span><span line-number="3" class=""><span class="tooltip-container"></span>LSP[Langoustine LSP][Info] ready to initialise!
</span><span line-number="4" class=""><span class="tooltip-container"></span>LSP[Langoustine LSP][Info] In total, 1 files registered!
</span><span line-number="5" class=""><span class="tooltip-container"></span>"[Prompt]" [Modified] 1 line --100%--
</span><span line-number="6" class=""><span class="tooltip-container"></span>"hello.langoustine" 0L, 0B
</span><span line-number="7" class=""><span class="tooltip-container"></span>LSP[Langoustine LSP][Info] In total, 2 files registered!
</span></code></pre>
  <div class="buttons"></div>
 </div>
</section></div><div id="toc" class="body-small"><div id="toc-container"><span class="toc-title h200">In this article</span><nav class="toc-nav"><ul class="toc-list"><li><a href="#getting-started-1">Getting started</a><ul><li><a href="#example-with-scala-cli-1">Example with Scala CLI</a><ul><li><a href="#using-cats-effect-recommended-1">Using Cats Effect (recommended)</a></li><li><a href="#using-future-1">Using Future</a></li></ul></li><li><a href="#packaging-and-distribution-1">Packaging and distribution</a><ul><li><a href="#publishing-and-launching-with-coursier-1">Publishing and launching with Coursier</a></li><li><a href="#packaging-for-nodejs-and-pkg-1">Packaging for Node.js and Pkg</a></li><li><a href="#packaging-as-a-native-application-1">Packaging as a native application</a></li></ul></li><li><a href="#editor-integration-1">Editor integration</a><ul><li><a href="#neovim-1">Neovim</a></li></ul></li></ul></li></ul></nav></div></div></div><div id="footer" class="body-small mobile-footer"><div class="left-container">Generated with</div><div class="right-container"><a href="https://github.com/neandertech/langoustine"><button class="icon-button gh"></button></a><div class="text">Copyright (c) 2022, Neandertech</div></div><div class="text-mobile">Copyright (c) 2022, Neandertech</div></div></div></div></body></html>